import pygame
import os
import math
import sys
import random
import neat
import numpy as np
screen_width = 1200
screen_height = 800
generation = 0
MAX_LIFETIME = 50 # 根据需要调整
class Car:
    def __init__(self):
        self.surface = pygame.image.load("Probe.png")
        self.surface = pygame.transform.scale(self.surface, (30, 30))
        self.rotate_surface = self.surface
        self.pos = [200, 480]
        self.angle = 0
        self.speed = 0
        self.center = [self.pos[0] + 15, self.pos[1] + 15] #g根据智能体大小不同需要调整这个参数
        self.radars = []
        self.radars_for_draw = []
        self.is_alive = True
        self.goal = False
        self.distance = 0
        self.time_spent = 0
        self.visited_positions = set()  # 用于记录已访问的位置
        self.recent_actions = []  # 记录最近的动作
        self.exploration_bonus = 5  # 初始化探索奖励
        self.exploration_penalty = 0  # 初始化探索惩罚
        self.previous_position = []  # 初始化上一次位置属性
        self.max_stuck_count = 5  # 设置一个阈值，表示允许在相同位置停留的最大次数

    def draw(self, screen):
        screen.blit(self.rotate_surface, self.pos)
        self.draw_radar(screen)

    def draw_radar(self, screen):
        for r in self.radars:
            pos, dist = r
            # 绘制雷达线和终点圆圈
            pygame.draw.line(screen, (0, 255, 0), self.center, pos, 1)
            pygame.draw.circle(screen, (0, 255, 0), (int(pos[0]), int(pos[1])), 5)

    def check_collision(self, map):
        self.is_alive = True
        for p in self.four_points:
            x, y = int(p[0]), int(p[1])
            if 0 <= x < map.get_width() and 0 <= y < map.get_height():
                color = map.get_at((x, y))
                # 只检测白色作为不可行区域
                if color == (255, 255, 255, 255):  # 检测到白色为障碍物
                    self.is_alive = False
                    print(f"Collision detected at ({x}, {y}), color: {color}")  # 调试信息
                    break
            else:
                self.is_alive = False
                print(f"Out of bounds detected at ({x}, {y}). Agent is now dead.")  # 调试信息
                break

    def check_radar(self, degree, map):
        len = 0
        x = int(self.center[0] + math.cos(math.radians(360 - (self.angle + degree))) * len)
        y = int(self.center[1] + math.sin(math.radians(360 - (self.angle + degree))) * len)

        while (0 <= x < map.get_width()) and (0 <= y < map.get_height()):
            color = map.get_at((x, y))
            # 检查是否为白色（不可行区域）
            if color == (255, 255, 255, 255):  # 白色为障碍物或不可行区域
                break  # 碰到障碍物或者边界，停止检测

            len += 1
            x = int(self.center[0] + math.cos(math.radians(360 - (self.angle + degree))) * len)
            y = int(self.center[1] + math.sin(math.radians(360 - (self.angle + degree))) * len)

        if 0 <= x < map.get_width() and 0 <= y < map.get_height():
            dist = int(math.sqrt(math.pow(x - self.center[0], 2) + math.pow(y - self.center[1], 2)))
            self.radars.append([(x, y), dist])
        else:
            self.radars.append([(self.center[0], self.center[1]), 500])

    def update(self, map):
        # Check speed
        self.speed = 5

        # Update position


        self.rotate_surface = self.rot_center(self.surface, self.angle)
        self.pos[0] += math.cos(math.radians(360 - self.angle)) * self.speed
        if self.pos[0] < 20:
            self.pos[0] = 20
        elif self.pos[0] > screen_width - 120:
            self.pos[0] = screen_width - 120

        self.distance += self.speed
        self.time_spent += 1
        if self.time_spent > MAX_LIFETIME:
            self.is_alive = False
        self.pos[1] += math.sin(math.radians(360 - self.angle)) * self.speed
        if self.pos[1] < 20:
            self.pos[1] = 20
        elif self.pos[1] > screen_height - 120:
            self.pos[1] = screen_height - 120

        # Calculate 4 collision points
        self.center = [int(self.pos[0]) + 15, int(self.pos[1]) + 15]  # 修改为新尺寸的中心

        length = 20
        left_top = [self.center[0] + math.cos(math.radians(360 - (self.angle + 30))) * length,
                    self.center[1] + math.sin(math.radians(360 - (self.angle + 30))) * length]
        right_top = [self.center[0] + math.cos(math.radians(360 - (self.angle + 150))) * length,
                     self.center[1] + math.sin(math.radians(360 - (self.angle + 150))) * length]
        left_bottom = [self.center[0] + math.cos(math.radians(360 - (self.angle + 210))) * length,
                       self.center[1] + math.sin(math.radians(360 - (self.angle + 210))) * length]
        right_bottom = [self.center[0] + math.cos(math.radians(360 - (self.angle + 330))) * length,
                        self.center[1] + math.sin(math.radians(360 - (self.angle + 330))) * length]
        self.four_points = [left_top, right_top, left_bottom, right_bottom]

        # Check for collisions and radar updates
        self.check_collision(map)
        self.radars.clear()
        for d in range(-90, 150, 30):
            self.check_radar(d, map)

        # 记录当前中心点位置
        grid_position = tuple(np.round(self.pos).astype(int))
        self.visited_positions.add(grid_position)
        print(f"Visited position: {grid_position}")
        self.check_stuck()

        # 如果卡住，直接将智能体设置为死亡
        if self.stuck_count > self.max_stuck_count:
            self.is_alive = False
            print(f"Car has been stuck at position {self.pos} and is now marked as dead.")

    def check_stuck(self):
        current_position = tuple(np.round(self.pos).astype(int))
        self.previous_position.append(current_position)

        if len(self.previous_position) > 10:
            self.previous_position.pop(0)

        self.stuck_count = self.previous_position.count(current_position)

        if self.stuck_count > 5:
            self.angle += np.random.choice([-45, 45])  # 增加随机转向角度
            self.speed = -3  # 增加后退速度
    def get_current_position(self):
        # 获取智能体当前的位置
        return (self.pos[0], self.pos[1])

    def get_data(self):
        radars = self.radars
        ret = [0, 0, 0, 0, 0]
        for i, r in enumerate(radars):
            if i < len(ret):  # 确保索引不超出 ret 的范围
                ret[i] = int(r[1] / 300)
            else:
                break  # 如果超过 ret 的范围，停止填充

        # 如果雷达数据不足5个，用最大距离填充剩余部分
        for j in range(len(radars), len(ret)):
            ret[j] = 1  # 假设默认距离数据归一化为1

        return ret

    def get_alive(self):
        return self.is_alive

    def get_reward(self):
        if not self.is_alive:
            return -200

        reward = -1

        grid_position = tuple(np.round(self.pos).astype(int))
        if grid_position not in self.visited_positions:
            self.visited_positions.add(grid_position)
            reward += 2000  # 增加探索新位置的奖励
        else:
            reward -= 100  # 减少重复访问位置的惩罚

        if self.time_spent > 50 and grid_position in self.visited_positions:
            reward -= 500

        reward -= self.time_spent * 0.01

        return reward

    def random_explore(self, generation):
        # 使用随时间衰减的探索率
        exploration_rate = max(0.1, 1 - (generation / 1000))
        if np.random.rand() < exploration_rate:
            return np.random.choice([0, 1, 2, 3, 4, 5, 6])  # 根据输出数量选择随机动作
        return None

    def check_stuck(self):
        current_position = tuple(np.round(self.pos).astype(int))
        self.previous_position.append(current_position)

        # 只保留最近的几个位置来检测卡住情况
        if len(self.previous_position) > 10:
            self.previous_position.pop(0)

        # 如果在最近的位置中，某个位置出现超过阈值次数，判定为卡住
        self.stuck_count = self.previous_position.count(current_position)

        # 如果卡住的次数超过一定的阈值，尝试逃逸
        if self.stuck_count > 5:
            self.angle += np.random.choice([-30, 30])  # 随机选择一个大的转向角度
            self.speed = -2  # 尝试后退以摆脱卡住的状态

    def rot_center(self, image, angle):
        orig_rect = image.get_rect(topleft=self.pos)
        rot_image = pygame.transform.rotate(image, angle)
        rot_rect = orig_rect.copy()
        rot_rect.center = rot_image.get_rect().center
        return rot_image


def run_car(genomes, config):

    # Init NEAT
    nets = []
    cars = []

    for id, g in genomes:
        net = neat.nn.FeedForwardNetwork.create(g, config)
        nets.append(net)
        g.fitness = 0

        # Init my cars
        cars.append(Car())

    # Init my game
    pygame.init()
    screen = pygame.display.set_mode((screen_width, screen_height))
    clock = pygame.time.Clock()
    generation_font = pygame.font.SysFont("Arial", 70)
    font = pygame.font.SysFont("Arial", 30)
    map = pygame.image.load('image1.png')


    # Main loop
    global generation
    generation += 1
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                sys.exit(0)


        # Input my data and get result from network
        # 输入数据并从神经网络获得结果
        for index, car in enumerate(cars):
            output = nets[index].activate(car.get_data())
            i = output.index(max(output))

            if i == 0:  # 小左转
                car.angle += 2
            elif i == 1:  # 大左转
                car.angle += 5
            elif i == 2:  # 小右转
                car.angle -= 2
            elif i == 3:  # 大右转
                car.angle -= 5
            elif i == 4:  # 加速
                car.speed = min(car.speed + 0.1, 6)
            elif i == 5:  # 减速
                car.speed = max(car.speed - 0.1, 1)
            elif i == 6:  # 后退
                car.speed = -min(car.speed, 2)

        # Update car and fitness
        remain_cars = 0
        for i, car in enumerate(cars):
            if car.get_alive():
                remain_cars += 1
                car.update(map)
                genomes[i][1].fitness += car.get_reward()

        # check
        if remain_cars == 0:
            break

        # Drawing
        screen.blit(map, (0, 0))
        for car in cars:
            if car.get_alive():
                car.draw(screen)

        text = generation_font.render("Generation : " + str(generation), True, (255, 255, 0))
        text_rect = text.get_rect()
        text_rect.center = (screen_width/2, 100)
        screen.blit(text, text_rect)

        text = font.render("remain cars : " + str(remain_cars), True, (0, 0, 0))
        text_rect = text.get_rect()
        text_rect.center = (screen_width/2, 200)
        screen.blit(text, text_rect)

        pygame.display.flip()
        clock.tick(20)

if __name__ == "__main__":
    # Set configuration file
    config_path = "./config-feedforward.txt"
    config = neat.config.Config(neat.DefaultGenome, neat.DefaultReproduction,
                                neat.DefaultSpeciesSet, neat.DefaultStagnation, config_path)

    # Create core evolution algorithm class
    p = neat.Population(config)

    # Add reporter for fancy statistical result
    p.add_reporter(neat.StdOutReporter(True))
    stats = neat.StatisticsReporter()
    p.add_reporter(stats)

    # Run NEAT
    p.run(run_car, 1000)
